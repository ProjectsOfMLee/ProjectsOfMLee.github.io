import {
  getCurrentInstance,
  inject,
  isRef,
  onBeforeUnmount,
  onMounted,
  provide,
  reactive,
  ref,
  watchEffect
} from "./chunk-SDHDXJ2N.js";

// node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs
var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
var nodejsCustomInspectSymbol_default = nodejsCustomInspectSymbol;

// node_modules/graphql/jsutils/inspect.mjs
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof5(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof5(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (_typeof(value)) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? "[function ".concat(value.name, "]") : "[function]";
    case "object":
      if (value === null) {
        return "null";
      }
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return "[Circular]";
  }
  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);
  if (customInspectFn !== void 0) {
    var customValue = customInspectFn.call(value);
    if (customValue !== value) {
      return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function formatObject(object, seenValues) {
  var keys = Object.keys(object);
  if (keys.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  var properties = keys.map(function(key) {
    var value = formatValue(object[key], seenValues);
    return key + ": " + value;
  });
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];
  for (var i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }
  return "[" + items.join(", ") + "]";
}
function getCustomFn(object) {
  var customInspectFn = object[String(nodejsCustomInspectSymbol_default)];
  if (typeof customInspectFn === "function") {
    return customInspectFn;
  }
  if (typeof object.inspect === "function") {
    return object.inspect;
  }
}
function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    var name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// node_modules/graphql/jsutils/defineInspect.mjs
function defineInspect(classObject) {
  var fn = classObject.prototype.toJSON;
  typeof fn === "function" || invariant(0);
  classObject.prototype.inspect = fn;
  if (nodejsCustomInspectSymbol_default) {
    classObject.prototype[nodejsCustomInspectSymbol_default] = fn;
  }
}

// node_modules/graphql/language/ast.mjs
var Location = function() {
  function Location2(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  var _proto = Location2.prototype;
  _proto.toJSON = function toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  };
  return Location2;
}();
defineInspect(Location);
var Token = function() {
  function Token2(kind, start, end, line, column, prev, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = prev;
    this.next = null;
  }
  var _proto2 = Token2.prototype;
  _proto2.toJSON = function toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  };
  return Token2;
}();
defineInspect(Token);
function isNode(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === "string";
}

// node_modules/graphql/language/visitor.mjs
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
  InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var BREAK = Object.freeze({});
function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
  var stack = void 0;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = void 0;
  var key = void 0;
  var parent = void 0;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone[k] = node[k];
          }
          node = clone;
        }
        var editOffset = 0;
        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];
          if (inArray) {
            editKey -= editOffset;
          }
          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : void 0;
      node = parent ? parent[key] : newRoot;
      if (node === null || node === void 0) {
        continue;
      }
      if (parent) {
        path.push(key);
      }
    }
    var result = void 0;
    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error("Invalid AST Node: ".concat(inspect(node), "."));
      }
      var visitFn = getVisitFn(visitor, node.kind, isLeaving);
      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _visitorKeys$node$kin;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }
  return newRoot;
}
function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];
  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === "function") {
      return kindVisitor;
    }
    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
    if (typeof kindSpecificVisitor === "function") {
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
    if (specificVisitor) {
      if (typeof specificVisitor === "function") {
        return specificVisitor;
      }
      var specificKindVisitor = specificVisitor[kind];
      if (typeof specificKindVisitor === "function") {
        return specificKindVisitor;
      }
    }
  }
}

// node_modules/graphql/language/kinds.mjs
var Kind = Object.freeze({
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType",
  SCHEMA_DEFINITION: "SchemaDefinition",
  OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
  SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
  OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
  FIELD_DEFINITION: "FieldDefinition",
  INPUT_VALUE_DEFINITION: "InputValueDefinition",
  INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
  UNION_TYPE_DEFINITION: "UnionTypeDefinition",
  ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
  ENUM_VALUE_DEFINITION: "EnumValueDefinition",
  INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
  DIRECTIVE_DEFINITION: "DirectiveDefinition",
  SCHEMA_EXTENSION: "SchemaExtension",
  SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
  OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
  INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
  UNION_TYPE_EXTENSION: "UnionTypeExtension",
  ENUM_TYPE_EXTENSION: "EnumTypeExtension",
  INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
});

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringValue(rawString) {
  var lines = rawString.split(/\r\n|[\n\r]/g);
  var commonIndent = getBlockStringIndentation(rawString);
  if (commonIndent !== 0) {
    for (var i2 = 1; i2 < lines.length; i2++) {
      lines[i2] = lines[i2].slice(commonIndent);
    }
  }
  var startLine = 0;
  while (startLine < lines.length && isBlank(lines[startLine])) {
    ++startLine;
  }
  var endLine = lines.length;
  while (endLine > startLine && isBlank(lines[endLine - 1])) {
    --endLine;
  }
  return lines.slice(startLine, endLine).join("\n");
}
function isBlank(str) {
  for (var i2 = 0; i2 < str.length; ++i2) {
    if (str[i2] !== " " && str[i2] !== "	") {
      return false;
    }
  }
  return true;
}
function getBlockStringIndentation(value) {
  var _commonIndent;
  var isFirstLine = true;
  var isEmptyLine = true;
  var indent2 = 0;
  var commonIndent = null;
  for (var i2 = 0; i2 < value.length; ++i2) {
    switch (value.charCodeAt(i2)) {
      case 13:
        if (value.charCodeAt(i2 + 1) === 10) {
          ++i2;
        }
      case 10:
        isFirstLine = false;
        isEmptyLine = true;
        indent2 = 0;
        break;
      case 9:
      case 32:
        ++indent2;
        break;
      default:
        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent2 < commonIndent)) {
          commonIndent = indent2;
        }
        isEmptyLine = false;
    }
  }
  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
}
function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isSingleLine = value.indexOf("\n") === -1;
  var hasLeadingSpace = value[0] === " " || value[0] === "	";
  var hasTrailingQuote = value[value.length - 1] === '"';
  var hasTrailingSlash = value[value.length - 1] === "\\";
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
  var result = "";
  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += "\n" + indentation;
  }
  result += indentation ? value.replace(/\n/g, "\n" + indentation) : value;
  if (printAsMultipleLines) {
    result += "\n";
  }
  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, {
    leave: printDocASTReducer
  });
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: function Name(node) {
    return node.value;
  },
  Variable: function Variable(node) {
    return "$" + node.name;
  },
  Document: function Document(node) {
    return join(node.definitions, "\n\n") + "\n";
  },
  OperationDefinition: function OperationDefinition(node) {
    var op = node.operation;
    var name = node.name;
    var varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
    var directives = join(node.directives, " ");
    var selectionSet = node.selectionSet;
    return !name && !directives && !varDefs && op === "query" ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], " ");
  },
  VariableDefinition: function VariableDefinition(_ref) {
    var variable = _ref.variable, type = _ref.type, defaultValue = _ref.defaultValue, directives = _ref.directives;
    return variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "));
  },
  SelectionSet: function SelectionSet(_ref2) {
    var selections = _ref2.selections;
    return block(selections);
  },
  Field: function Field(_ref3) {
    var alias = _ref3.alias, name = _ref3.name, args = _ref3.arguments, directives = _ref3.directives, selectionSet = _ref3.selectionSet;
    var prefix = wrap("", alias, ": ") + name;
    var argsLine = prefix + wrap("(", join(args, ", "), ")");
    if (argsLine.length > MAX_LINE_LENGTH) {
      argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
    }
    return join([argsLine, join(directives, " "), selectionSet], " ");
  },
  Argument: function Argument(_ref4) {
    var name = _ref4.name, value = _ref4.value;
    return name + ": " + value;
  },
  FragmentSpread: function FragmentSpread(_ref5) {
    var name = _ref5.name, directives = _ref5.directives;
    return "..." + name + wrap(" ", join(directives, " "));
  },
  InlineFragment: function InlineFragment(_ref6) {
    var typeCondition = _ref6.typeCondition, directives = _ref6.directives, selectionSet = _ref6.selectionSet;
    return join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ");
  },
  FragmentDefinition: function FragmentDefinition(_ref7) {
    var name = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives = _ref7.directives, selectionSet = _ref7.selectionSet;
    return "fragment ".concat(name).concat(wrap("(", join(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap("", join(directives, " "), " ")) + selectionSet;
  },
  IntValue: function IntValue(_ref8) {
    var value = _ref8.value;
    return value;
  },
  FloatValue: function FloatValue(_ref9) {
    var value = _ref9.value;
    return value;
  },
  StringValue: function StringValue(_ref10, key) {
    var value = _ref10.value, isBlockString = _ref10.block;
    return isBlockString ? printBlockString(value, key === "description" ? "" : "  ") : JSON.stringify(value);
  },
  BooleanValue: function BooleanValue(_ref11) {
    var value = _ref11.value;
    return value ? "true" : "false";
  },
  NullValue: function NullValue() {
    return "null";
  },
  EnumValue: function EnumValue(_ref12) {
    var value = _ref12.value;
    return value;
  },
  ListValue: function ListValue(_ref13) {
    var values = _ref13.values;
    return "[" + join(values, ", ") + "]";
  },
  ObjectValue: function ObjectValue(_ref14) {
    var fields = _ref14.fields;
    return "{" + join(fields, ", ") + "}";
  },
  ObjectField: function ObjectField(_ref15) {
    var name = _ref15.name, value = _ref15.value;
    return name + ": " + value;
  },
  Directive: function Directive(_ref16) {
    var name = _ref16.name, args = _ref16.arguments;
    return "@" + name + wrap("(", join(args, ", "), ")");
  },
  NamedType: function NamedType(_ref17) {
    var name = _ref17.name;
    return name;
  },
  ListType: function ListType(_ref18) {
    var type = _ref18.type;
    return "[" + type + "]";
  },
  NonNullType: function NonNullType(_ref19) {
    var type = _ref19.type;
    return type + "!";
  },
  SchemaDefinition: addDescription(function(_ref20) {
    var directives = _ref20.directives, operationTypes = _ref20.operationTypes;
    return join(["schema", join(directives, " "), block(operationTypes)], " ");
  }),
  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
    var operation = _ref21.operation, type = _ref21.type;
    return operation + ": " + type;
  },
  ScalarTypeDefinition: addDescription(function(_ref22) {
    var name = _ref22.name, directives = _ref22.directives;
    return join(["scalar", name, join(directives, " ")], " ");
  }),
  ObjectTypeDefinition: addDescription(function(_ref23) {
    var name = _ref23.name, interfaces = _ref23.interfaces, directives = _ref23.directives, fields = _ref23.fields;
    return join(["type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
  }),
  FieldDefinition: addDescription(function(_ref24) {
    var name = _ref24.name, args = _ref24.arguments, type = _ref24.type, directives = _ref24.directives;
    return name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "));
  }),
  InputValueDefinition: addDescription(function(_ref25) {
    var name = _ref25.name, type = _ref25.type, defaultValue = _ref25.defaultValue, directives = _ref25.directives;
    return join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ");
  }),
  InterfaceTypeDefinition: addDescription(function(_ref26) {
    var name = _ref26.name, interfaces = _ref26.interfaces, directives = _ref26.directives, fields = _ref26.fields;
    return join(["interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
  }),
  UnionTypeDefinition: addDescription(function(_ref27) {
    var name = _ref27.name, directives = _ref27.directives, types = _ref27.types;
    return join(["union", name, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
  }),
  EnumTypeDefinition: addDescription(function(_ref28) {
    var name = _ref28.name, directives = _ref28.directives, values = _ref28.values;
    return join(["enum", name, join(directives, " "), block(values)], " ");
  }),
  EnumValueDefinition: addDescription(function(_ref29) {
    var name = _ref29.name, directives = _ref29.directives;
    return join([name, join(directives, " ")], " ");
  }),
  InputObjectTypeDefinition: addDescription(function(_ref30) {
    var name = _ref30.name, directives = _ref30.directives, fields = _ref30.fields;
    return join(["input", name, join(directives, " "), block(fields)], " ");
  }),
  DirectiveDefinition: addDescription(function(_ref31) {
    var name = _ref31.name, args = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
    return "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ");
  }),
  SchemaExtension: function SchemaExtension(_ref32) {
    var directives = _ref32.directives, operationTypes = _ref32.operationTypes;
    return join(["extend schema", join(directives, " "), block(operationTypes)], " ");
  },
  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
    var name = _ref33.name, directives = _ref33.directives;
    return join(["extend scalar", name, join(directives, " ")], " ");
  },
  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
    var name = _ref34.name, interfaces = _ref34.interfaces, directives = _ref34.directives, fields = _ref34.fields;
    return join(["extend type", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
  },
  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
    var name = _ref35.name, interfaces = _ref35.interfaces, directives = _ref35.directives, fields = _ref35.fields;
    return join(["extend interface", name, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields)], " ");
  },
  UnionTypeExtension: function UnionTypeExtension(_ref36) {
    var name = _ref36.name, directives = _ref36.directives, types = _ref36.types;
    return join(["extend union", name, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
  },
  EnumTypeExtension: function EnumTypeExtension(_ref37) {
    var name = _ref37.name, directives = _ref37.directives, values = _ref37.values;
    return join(["extend enum", name, join(directives, " "), block(values)], " ");
  },
  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
    var name = _ref38.name, directives = _ref38.directives, fields = _ref38.fields;
    return join(["extend input", name, join(directives, " "), block(fields)], " ");
  }
};
function addDescription(cb) {
  return function(node) {
    return join([node.description, cb(node)], "\n");
  };
}
function join(maybeArray) {
  var _maybeArray$filter$jo;
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function(x2) {
    return x2;
  }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString) {
  var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function isMultiline(str) {
  return str.indexOf("\n") !== -1;
}
function hasMultilineItems(maybeArray) {
  return maybeArray != null && maybeArray.some(isMultiline);
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof5(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function _typeof5(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function isObjectLike(value) {
  return _typeof2(value) == "object" && value !== null;
}

// node_modules/graphql/polyfills/symbols.mjs
var SYMBOL_ITERATOR = typeof Symbol === "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
var SYMBOL_ASYNC_ITERATOR = typeof Symbol === "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";

// node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;
  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }
  return {
    line,
    column
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(location.source, getLocation(location.source, location.start));
}
function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    var subLineIndex = Math.floor(columnNum / 80);
    var subLineColumnNum = columnNum % 80;
    var subLines = [];
    for (var i2 = 0; i2 < locationLine.length; i2 += 80) {
      subLines.push(locationLine.slice(i2, i2 + 80));
    }
    return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
      return ["", subLine];
    }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
  }
  return locationStr + printPrefixedLines([
    ["".concat(lineNum - 1), lines[lineIndex - 1]],
    ["".concat(lineNum), locationLine],
    ["", whitespace(columnNum - 1) + "^"],
    ["".concat(lineNum + 1), lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  var existingLines = lines.filter(function(_ref) {
    var _ = _ref[0], line = _ref[1];
    return line !== void 0;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function(_ref3) {
    var prefix = _ref3[0], line = _ref3[1];
    return leftPad(padLen, prefix) + (line ? " | " + line : " |");
  }).join("\n");
}
function whitespace(len) {
  return Array(len + 1).join(" ");
}
function leftPad(len, str) {
  return whitespace(len - str.length) + str;
}

// node_modules/graphql/error/GraphQLError.mjs
function _typeof3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof3 = function _typeof5(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof3 = function _typeof5(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof3(obj);
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o2, p3) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p4) {
    o3.__proto__ = p4;
    return o3;
  };
  return _setPrototypeOf(o2, p3);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
var GraphQLError = function(_Error) {
  _inherits(GraphQLError2, _Error);
  var _super = _createSuper(GraphQLError2);
  function GraphQLError2(message, nodes, source, positions, path, originalError, extensions) {
    var _nodeLocations, _nodeLocations2, _nodeLocations3;
    var _this;
    _classCallCheck(this, GraphQLError2);
    _this = _super.call(this, message);
    _this.name = "GraphQLError";
    _this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    _this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
    var nodeLocations = [];
    for (var _i2 = 0, _ref3 = (_this$nodes = _this.nodes) !== null && _this$nodes !== void 0 ? _this$nodes : []; _i2 < _ref3.length; _i2++) {
      var _this$nodes;
      var _ref4 = _ref3[_i2];
      var loc = _ref4.loc;
      if (loc != null) {
        nodeLocations.push(loc);
      }
    }
    nodeLocations = undefinedIfEmpty(nodeLocations);
    _this.source = source !== null && source !== void 0 ? source : (_nodeLocations = nodeLocations) === null || _nodeLocations === void 0 ? void 0 : _nodeLocations[0].source;
    _this.positions = positions !== null && positions !== void 0 ? positions : (_nodeLocations2 = nodeLocations) === null || _nodeLocations2 === void 0 ? void 0 : _nodeLocations2.map(function(loc2) {
      return loc2.start;
    });
    _this.locations = positions && source ? positions.map(function(pos) {
      return getLocation(source, pos);
    }) : (_nodeLocations3 = nodeLocations) === null || _nodeLocations3 === void 0 ? void 0 : _nodeLocations3.map(function(loc2) {
      return getLocation(loc2.source, loc2.start);
    });
    _this.path = path !== null && path !== void 0 ? path : void 0;
    var originalExtensions = originalError === null || originalError === void 0 ? void 0 : originalError.extensions;
    if (extensions == null && isObjectLike(originalExtensions)) {
      _this.extensions = _objectSpread({}, originalExtensions);
    } else {
      _this.extensions = extensions !== null && extensions !== void 0 ? extensions : {};
    }
    Object.defineProperties(_assertThisInitialized(_this), {
      message: {
        enumerable: true
      },
      locations: {
        enumerable: _this.locations != null
      },
      path: {
        enumerable: _this.path != null
      },
      extensions: {
        enumerable: _this.extensions != null && Object.keys(_this.extensions).length > 0
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
      return _possibleConstructorReturn(_this);
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
    } else {
      Object.defineProperty(_assertThisInitialized(_this), "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
    return _this;
  }
  _createClass(GraphQLError2, [{
    key: "toString",
    value: function toString() {
      return printError(this);
    }
  }, {
    key: SYMBOL_TO_STRING_TAG,
    get: function get() {
      return "Object";
    }
  }]);
  return GraphQLError2;
}(_wrapNativeSuper(Error));
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error) {
  var output = error.message;
  if (error.nodes) {
    for (var _i4 = 0, _error$nodes2 = error.nodes; _i4 < _error$nodes2.length; _i4++) {
      var node = _error$nodes2[_i4];
      if (node.loc) {
        output += "\n\n" + printLocation(node.loc);
      }
    }
  } else if (error.source && error.locations) {
    for (var _i6 = 0, _error$locations2 = error.locations; _i6 < _error$locations2.length; _i6++) {
      var location = _error$locations2[_i6];
      output += "\n\n" + printSourceLocation(error.source, location);
    }
  }
  return output;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError("Syntax Error: ".concat(description), void 0, source, [position]);
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind = Object.freeze({
  SOF: "<SOF>",
  EOF: "<EOF>",
  BANG: "!",
  DOLLAR: "$",
  AMP: "&",
  PAREN_L: "(",
  PAREN_R: ")",
  SPREAD: "...",
  COLON: ":",
  EQUALS: "=",
  AT: "@",
  BRACKET_L: "[",
  BRACKET_R: "]",
  BRACE_L: "{",
  PIPE: "|",
  BRACE_R: "}",
  NAME: "Name",
  INT: "Int",
  FLOAT: "Float",
  STRING: "String",
  BLOCK_STRING: "BlockString",
  COMMENT: "Comment"
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/instanceOf.mjs
function _typeof4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof4 = function _typeof5(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof4 = function _typeof5(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof4(obj);
}
var instanceOf_default = false ? function instanceOf(value, constructor) {
  return value instanceof constructor;
} : function instanceOf2(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (_typeof4(value) === "object" && value !== null) {
    var _value$constructor;
    var className = constructor.prototype[Symbol.toStringTag];
    var valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
    if (className === valueClassName) {
      var stringifiedValue = inspect(value);
      throw new Error("Cannot use ".concat(className, ' "').concat(stringifiedValue, '" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.'));
    }
  }
  return false;
};

// node_modules/graphql/language/source.mjs
function _defineProperties2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
var Source = function() {
  function Source2(body) {
    var name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
    var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      line: 1,
      column: 1
    };
    typeof body === "string" || devAssert(0, "Body must be a string. Received: ".concat(inspect(body), "."));
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(0, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(0, "column in locationOffset is 1-indexed and must be positive.");
  }
  _createClass2(Source2, [{
    key: SYMBOL_TO_STRING_TAG,
    get: function get() {
      return "Source";
    }
  }]);
  return Source2;
}();
function isSource(source) {
  return instanceOf_default(source, Source);
}

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation = Object.freeze({
  QUERY: "QUERY",
  MUTATION: "MUTATION",
  SUBSCRIPTION: "SUBSCRIPTION",
  FIELD: "FIELD",
  FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
  FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
  INLINE_FRAGMENT: "INLINE_FRAGMENT",
  VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
  SCHEMA: "SCHEMA",
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  FIELD_DEFINITION: "FIELD_DEFINITION",
  ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  ENUM_VALUE: "ENUM_VALUE",
  INPUT_OBJECT: "INPUT_OBJECT",
  INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
});

// node_modules/graphql/language/lexer.mjs
var Lexer = function() {
  function Lexer2(source) {
    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  var _proto = Lexer2.prototype;
  _proto.advance = function advance() {
    this.lastToken = this.token;
    var token = this.token = this.lookahead();
    return token;
  };
  _proto.lookahead = function lookahead() {
    var token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        var _token$next;
        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  };
  return Lexer2;
}();
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function printCharCode(code) {
  return isNaN(code) ? TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"');
}
function readToken(lexer, prev) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = prev.end;
  while (pos < bodyLength) {
    var code = body.charCodeAt(pos);
    var _line = lexer.line;
    var _col = 1 + pos - lexer.lineStart;
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++pos;
        continue;
      case 10:
        ++pos;
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 13:
        if (body.charCodeAt(pos + 1) === 10) {
          pos += 2;
        } else {
          ++pos;
        }
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 33:
        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);
      case 35:
        return readComment(source, pos, _line, _col, prev);
      case 36:
        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
      case 38:
        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);
      case 40:
        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
      case 41:
        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
      case 46:
        if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
        }
        break;
      case 58:
        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);
      case 61:
        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
      case 64:
        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);
      case 91:
        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
      case 93:
        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
      case 123:
        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
      case 124:
        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
      case 125:
        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
      case 34:
        if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
          return readBlockString(source, pos, _line, _col, prev, lexer);
        }
        return readString(source, pos, _line, _col, prev);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return readNumber(source, pos, code, _line, _col, prev);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return readName(source, pos, _line, _col, prev);
    }
    throw syntaxError(source, pos, unexpectedCharacterMessage(code));
  }
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;
  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
}
function unexpectedCharacterMessage(code) {
  if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
    return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
  }
  if (code === 39) {
    return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
  }
  return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
}
function readComment(source, start, line, col, prev) {
  var body = source.body;
  var code;
  var position = start;
  do {
    code = body.charCodeAt(++position);
  } while (!isNaN(code) && (code > 31 || code === 9));
  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
}
function readNumber(source, start, firstCode, line, col, prev) {
  var body = source.body;
  var code = firstCode;
  var position = start;
  var isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (code >= 48 && code <= 57) {
      throw syntaxError(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
    }
  } else {
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
  }
  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
}
function readDigits(source, start, firstCode) {
  var body = source.body;
  var position = start;
  var code = firstCode;
  if (code >= 48 && code <= 57) {
    do {
      code = body.charCodeAt(++position);
    } while (code >= 48 && code <= 57);
    return position;
  }
  throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}
function readString(source, start, line, col, prev) {
  var body = source.body;
  var position = start + 1;
  var chunkStart = position;
  var code = 0;
  var value = "";
  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && code !== 10 && code !== 13) {
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);
    }
    if (code < 32 && code !== 9) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }
    ++position;
    if (code === 92) {
      value += body.slice(chunkStart, position - 1);
      code = body.charCodeAt(position);
      switch (code) {
        case 34:
          value += '"';
          break;
        case 47:
          value += "/";
          break;
        case 92:
          value += "\\";
          break;
        case 98:
          value += "\b";
          break;
        case 102:
          value += "\f";
          break;
        case 110:
          value += "\n";
          break;
        case 114:
          value += "\r";
          break;
        case 116:
          value += "	";
          break;
        case 117: {
          var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));
          if (charCode < 0) {
            var invalidSequence = body.slice(position + 1, position + 5);
            throw syntaxError(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
          }
          value += String.fromCharCode(charCode);
          position += 4;
          break;
        }
        default:
          throw syntaxError(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
      }
      ++position;
      chunkStart = position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function readBlockString(source, start, line, col, prev, lexer) {
  var body = source.body;
  var position = start + 3;
  var chunkStart = position;
  var code = 0;
  var rawValue = "";
  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      rawValue += body.slice(chunkStart, position);
      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));
    }
    if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }
    if (code === 10) {
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      rawValue += body.slice(chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function uniCharCode(a, b, c2, d2) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c2) << 4 | char2hex(d2);
}
function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
}
function readName(source, start, line, col, prev) {
  var body = source.body;
  var bodyLength = body.length;
  var position = start + 1;
  var code = 0;
  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
    ++position;
  }
  return new Token(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
}
function isNameStart(code) {
  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
}

// node_modules/graphql/language/parser.mjs
function parse(source, options) {
  var parser = new Parser(source, options);
  return parser.parseDocument();
}
var Parser = function() {
  function Parser2(source, options) {
    var sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
  }
  var _proto = Parser2.prototype;
  _proto.parseName = function parseName() {
    var token = this.expectToken(TokenKind.NAME);
    return {
      kind: Kind.NAME,
      value: token.value,
      loc: this.loc(token)
    };
  };
  _proto.parseDocument = function parseDocument() {
    var start = this._lexer.token;
    return {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
      loc: this.loc(start)
    };
  };
  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(TokenKind.NAME)) {
      switch (this._lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "directive":
          return this.parseTypeSystemDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    } else if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }
    throw this.unexpected();
  };
  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return {
        kind: Kind.OPERATION_DEFINITION,
        operation: "query",
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    var operation = this.parseOperationType();
    var name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return "query";
      case "mutation":
        return "mutation";
      case "subscription":
        return "subscription";
    }
    throw this.unexpected(operationToken);
  };
  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  };
  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start = this._lexer.token;
    return {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
      directives: this.parseDirectives(true),
      loc: this.loc(start)
    };
  };
  _proto.parseVariable = function parseVariable() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return {
      kind: Kind.VARIABLE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseSelectionSet = function parseSelectionSet() {
    var start = this._lexer.token;
    return {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseSelection = function parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  };
  _proto.parseField = function parseField() {
    var start = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
      loc: this.loc(start)
    };
  };
  _proto.parseArguments = function parseArguments(isConst) {
    var item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  };
  _proto.parseArgument = function parseArgument() {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(false),
      loc: this.loc(start)
    };
  };
  _proto.parseConstArgument = function parseConstArgument() {
    var start = this._lexer.token;
    return {
      kind: Kind.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),
      loc: this.loc(start)
    };
  };
  _proto.parseFragment = function parseFragment() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var _this$_options;
    var start = this._lexer.token;
    this.expectKeyword("fragment");
    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
      return {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentName = function parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  };
  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this._lexer.advance();
        return {
          kind: Kind.INT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.FLOAT:
        this._lexer.advance();
        return {
          kind: Kind.FLOAT,
          value: token.value,
          loc: this.loc(token)
        };
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this._lexer.advance();
        switch (token.value) {
          case "true":
            return {
              kind: Kind.BOOLEAN,
              value: true,
              loc: this.loc(token)
            };
          case "false":
            return {
              kind: Kind.BOOLEAN,
              value: false,
              loc: this.loc(token)
            };
          case "null":
            return {
              kind: Kind.NULL,
              loc: this.loc(token)
            };
          default:
            return {
              kind: Kind.ENUM,
              value: token.value,
              loc: this.loc(token)
            };
        }
      case TokenKind.DOLLAR:
        if (!isConst) {
          return this.parseVariable();
        }
        break;
    }
    throw this.unexpected();
  };
  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;
    this._lexer.advance();
    return {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING,
      loc: this.loc(token)
    };
  };
  _proto.parseList = function parseList(isConst) {
    var _this = this;
    var start = this._lexer.token;
    var item = function item2() {
      return _this.parseValueLiteral(isConst);
    };
    return {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;
    var start = this._lexer.token;
    var item = function item2() {
      return _this2.parseObjectField(isConst);
    };
    return {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObjectField = function parseObjectField(isConst) {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  };
  _proto.parseDirective = function parseDirective(isConst) {
    var start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeReference = function parseTypeReference() {
    var start = this._lexer.token;
    var type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      type = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = {
        kind: Kind.LIST_TYPE,
        type,
        loc: this.loc(start)
      };
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return {
        kind: Kind.NON_NULL_TYPE,
        type,
        loc: this.loc(start)
      };
    }
    return type;
  };
  _proto.parseNamedType = function parseNamedType() {
    var start = this._lexer.token;
    return {
      kind: Kind.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.peekDescription = function peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  };
  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  };
  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("schema");
    var directives = this.parseDirectives(true);
    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    var type = this.parseNamedType();
    return {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var _this$_options2;
    if (!this.expectOptionalKeyword("implements")) {
      return [];
    }
    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
      var types = [];
      this.expectOptionalToken(TokenKind.AMP);
      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));
      return types;
    }
    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);
  };
  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    var _this$_options3;
    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
      this._lexer.advance();
      this._lexer.advance();
      return [];
    }
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  };
  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    var type = this.parseTypeReference();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  };
  _proto.parseInputValueDef = function parseInputValueDef() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    var type = this.parseTypeReference();
    var defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseValueLiteral(true);
    }
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("interface");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("union");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    return {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  };
  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    return {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  };
  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    return {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("input");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    return {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  };
  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    var directives = this.parseDirectives(true);
    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(true);
    var fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    var name = this.parseName();
    var directives = this.parseDirectives(true);
    var fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    var locations = this.parseDirectiveLocations();
    return {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  };
  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start = this._lexer.token;
    var name = this.parseName();
    if (DirectiveLocation[name.value] !== void 0) {
      return name;
    }
    throw this.unexpected(start);
  };
  _proto.loc = function loc(startToken) {
    var _this$_options4;
    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
      return new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
  };
  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  };
  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
  };
  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    return void 0;
  };
  _proto.expectKeyword = function expectKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw syntaxError(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
    }
  };
  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
      return true;
    }
    return false;
  };
  _proto.unexpected = function unexpected(atToken) {
    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
  };
  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  };
  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  };
  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  };
  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  };
  return Parser2;
}();
function getTokenDesc(token) {
  var value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? '"'.concat(kind, '"') : kind;
}

// node_modules/wonka/dist/wonka.mjs
function l(a, b) {
  b.tag = a;
  return b;
}
function m() {
}
function p(a) {
  return function(b) {
    var c2 = a.length;
    let d2 = false, e = false, f2 = false, g = 0;
    b(
      l(0, [
        function(h3) {
          if (h3) {
            d2 = true;
          } else if (e) {
            f2 = true;
          } else {
            for (e = f2 = true; f2 && !d2; ) {
              g < c2 ? (h3 = a[g], g = g + 1 | 0, f2 = false, b(l(1, [h3]))) : (d2 = true, b(0));
            }
            e = false;
          }
        }
      ])
    );
  };
}
function r() {
}
function t(a) {
  a(0);
}
function u(a) {
  let b = false;
  a(
    l(0, [
      function(c2) {
        c2 ? b = true : b || a(0);
      }
    ])
  );
}
function C(a) {
  return a(0);
}
function D(a) {
  return function(b) {
    return function(c2) {
      let e = m, f2 = false, g = [], h3 = false;
      b(function(b2) {
        "number" == typeof b2 ? h3 || (h3 = true, 0 === g.length && c2(0)) : b2.tag ? h3 || (f2 = false, function(a2) {
          function b3(a3) {
            "number" == typeof a3 ? 0 !== g.length && (g = g.filter(d2), a3 = 0 === g.length, h3 && a3 ? c2(0) : !f2 && a3 && (f2 = true, e(0))) : a3.tag ? 0 !== g.length && (c2(l(1, [a3[0]])), k(0)) : (k = a3 = a3[0], g = g.concat(a3), a3(0));
          }
          function d2(a3) {
            return a3 !== k;
          }
          let k = m;
          1 === a2.length ? a2(b3) : a2.bind(null, b3);
        }(a(b2[0])), f2 || (f2 = true, e(0))) : e = b2[0];
      });
      c2(
        l(0, [
          function(a2) {
            a2 ? (h3 || (h3 = true, e(a2)), g.forEach(function(c3) {
              return c3(a2);
            }), g = []) : (f2 || h3 ? f2 = false : (f2 = true, e(0)), g.forEach(C));
          }
        ])
      );
    };
  };
}
function E(a) {
  return a;
}
function H(a) {
  return function(b) {
    return function(c2) {
      let d2 = false;
      return b(function(e) {
        if ("number" == typeof e) {
          d2 || (d2 = true, c2(e));
        } else if (e.tag) {
          d2 || (a(e[0]), c2(e));
        } else {
          var g = e[0];
          c2(
            l(0, [
              function(a2) {
                if (!d2) {
                  return a2 && (d2 = true), g(a2);
                }
              }
            ])
          );
        }
      });
    };
  };
}
function J(a) {
  a(0);
}
function K(a) {
  return function(b) {
    return function(c2) {
      function d2(a2) {
        h3 && ("number" == typeof a2 ? (h3 = false, n ? c2(a2) : f2 || (f2 = true, e(0))) : a2.tag ? (c2(a2), k ? k = false : g(0)) : (g = a2 = a2[0], k = false, a2(0)));
      }
      let e = m, f2 = false, g = m, h3 = false, k = false, n = false;
      b(function(b2) {
        "number" == typeof b2 ? n || (n = true, h3 || c2(0)) : b2.tag ? n || (h3 && (g(1), g = m), f2 ? f2 = false : (f2 = true, e(0)), b2 = a(b2[0]), h3 = true, b2(d2)) : e = b2[0];
      });
      c2(
        l(0, [
          function(a2) {
            if (a2) {
              if (n || (n = true, e(1)), h3) {
                return h3 = false, g(1);
              }
            } else {
              n || f2 || (f2 = true, e(0)), h3 && !k && (k = true, g(0));
            }
          }
        ])
      );
    };
  };
}
function M(a) {
  return function(b) {
    return function(c2) {
      let d2 = [], e = m;
      return b(function(b2) {
        "number" == typeof b2 ? p(d2)(c2) : b2.tag ? (d2.length >= a && 0 < a && d2.shift(), d2.push(b2[0]), e(0)) : (b2 = b2[0], 0 >= a ? (b2(1), u(c2)) : (e = b2, b2(0)));
      });
    };
  };
}
function N(a) {
  return function(b) {
    let c2 = m, d2 = false;
    b(function(e) {
      "number" == typeof e ? d2 = true : e.tag ? d2 || (a(e[0]), c2(0)) : (c2 = e = e[0], e(0));
    });
    return {
      unsubscribe: function() {
        if (!d2) {
          return d2 = true, c2(1);
        }
      }
    };
  };
}
function O() {
}
function filter$1(a) {
  return function(b) {
    return function(c2) {
      let d2 = m;
      return b(function(b2) {
        "number" == typeof b2 ? c2(b2) : b2.tag ? a(b2[0]) ? c2(b2) : d2(0) : (d2 = b2[0], c2(b2));
      });
    };
  };
}
function fromValue$1(a) {
  return function(b) {
    let c2 = false;
    b(
      l(0, [
        function(d2) {
          d2 ? c2 = true : c2 || (c2 = true, b(l(1, [a])), b(0));
        }
      ])
    );
  };
}
function make$1(a) {
  return function(b) {
    let c2 = r, d2 = false;
    c2 = a({
      next: function(a2) {
        d2 || b(l(1, [a2]));
      },
      complete: function() {
        d2 || (d2 = true, b(0));
      }
    });
    b(
      l(0, [
        function(a2) {
          if (a2 && !d2) {
            return d2 = true, c2();
          }
        }
      ])
    );
  };
}
function makeSubject$1() {
  let a = [], b = false;
  return {
    source: function(c2) {
      function b2(a2) {
        return a2 !== c2;
      }
      a = a.concat(c2);
      c2(
        l(0, [
          function(c3) {
            c3 && (a = a.filter(b2));
          }
        ])
      );
    },
    next: function(c2) {
      b || a.forEach(function(a2) {
        a2(l(1, [c2]));
      });
    },
    complete: function() {
      b || (b = true, a.forEach(t));
    }
  };
}
function map$1(a) {
  return function(b) {
    return function(c2) {
      return b(function(b2) {
        b2 = "number" == typeof b2 ? 0 : b2.tag ? l(1, [a(b2[0])]) : l(0, [b2[0]]);
        c2(b2);
      });
    };
  };
}
function merge$1(a) {
  return D(E)(p(a));
}
function onEnd$1(a) {
  return function(b) {
    return function(c2) {
      let d2 = false;
      return b(function(b2) {
        if ("number" == typeof b2) {
          if (d2) {
            return;
          }
          d2 = true;
          c2(b2);
          return a();
        }
        if (b2.tag) {
          d2 || c2(b2);
        } else {
          var e = b2[0];
          c2(
            l(0, [
              function(c3) {
                if (!d2) {
                  return c3 ? (d2 = true, e(c3), a()) : e(c3);
                }
              }
            ])
          );
        }
      });
    };
  };
}
function onStart$1(a) {
  return function(b) {
    return function(c2) {
      return b(function(b2) {
        "number" == typeof b2 ? c2(b2) : b2.tag ? c2(b2) : (c2(b2), a());
      });
    };
  };
}
function publish$1(a) {
  return N(O)(a);
}
function share$1(a) {
  function b(a2) {
    "number" == typeof a2 ? (c2.forEach(J), c2 = []) : a2.tag ? (e = false, c2.forEach(function(b2) {
      b2(a2);
    })) : d2 = a2[0];
  }
  let c2 = [], d2 = m, e = false;
  return function(f2) {
    function g(a2) {
      return a2 !== f2;
    }
    c2 = c2.concat(f2);
    1 === c2.length && a(b);
    f2(
      l(0, [
        function(a2) {
          if (a2) {
            if (c2 = c2.filter(g), 0 === c2.length) {
              return d2(1);
            }
          } else {
            e || (e = true, d2(a2));
          }
        }
      ])
    );
  };
}
function take$1(a) {
  return function(b) {
    return function(c2) {
      let d2 = false, e = 0, f2 = m;
      b(function(b2) {
        "number" == typeof b2 ? d2 || (d2 = true, c2(0)) : b2.tag ? e < a && !d2 && (e = e + 1 | 0, c2(b2), !d2 && e >= a && (d2 = true, c2(0), f2(1))) : (b2 = b2[0], 0 >= a ? (d2 = true, c2(0), b2(1)) : f2 = b2);
      });
      c2(
        l(0, [
          function(b2) {
            if (!d2) {
              if (b2) {
                return d2 = true, f2(1);
              }
              if (e < a) {
                return f2(0);
              }
            }
          }
        ])
      );
    };
  };
}
function takeUntil$1(a) {
  return function(b) {
    return function(c2) {
      function d2(a2) {
        "number" != typeof a2 && (a2.tag ? (e = true, f2(1), c2(0)) : (g = a2 = a2[0], a2(0)));
      }
      let e = false, f2 = m, g = m;
      b(function(b2) {
        "number" == typeof b2 ? e || (e = true, g(1), c2(0)) : b2.tag ? e || c2(b2) : (f2 = b2[0], a(d2));
      });
      c2(
        l(0, [
          function(a2) {
            if (!e) {
              return a2 ? (e = true, f2(1), g(1)) : f2(0);
            }
          }
        ])
      );
    };
  };
}
function toPromise$1(a) {
  return new Promise(function(b) {
    M(1)(a)(function(a2) {
      if ("number" != typeof a2) {
        if (a2.tag) {
          b(a2[0]);
        } else {
          a2[0](0);
        }
      }
    });
  });
}
var P = "function" == typeof Symbol ? Symbol.observable || (Symbol.observable = Symbol("observable")) : "@@observable";

// node_modules/@urql/core/dist/2ce501b4.mjs
function rehydrateGraphQlError(r2) {
  if ("string" == typeof r2) {
    return new GraphQLError(r2);
  } else if ("object" == typeof r2 && r2.message) {
    return new GraphQLError(r2.message, r2.nodes, r2.source, r2.positions, r2.path, r2, r2.extensions || {});
  } else {
    return r2;
  }
}
var o = function(e) {
  function CombinedError(r2) {
    var t2 = r2.networkError;
    var n = r2.response;
    var a = (r2.graphQLErrors || []).map(rehydrateGraphQlError);
    var o2 = function generateErrorMessage(e2, r3) {
      var t3 = "";
      if (void 0 !== e2) {
        return t3 = "[Network] " + e2.message;
      }
      if (void 0 !== r3) {
        r3.forEach(function(e3) {
          t3 += "[GraphQL] " + e3.message + "\n";
        });
      }
      return t3.trim();
    }(t2, a);
    e.call(this, o2);
    this.name = "CombinedError";
    this.message = o2;
    this.graphQLErrors = a;
    this.networkError = t2;
    this.response = n;
  }
  if (e) {
    CombinedError.__proto__ = e;
  }
  (CombinedError.prototype = Object.create(e && e.prototype)).constructor = CombinedError;
  CombinedError.prototype.toString = function toString() {
    return this.message;
  };
  return CombinedError;
}(Error);
function phash(e, r2) {
  e |= 0;
  for (var t2 = 0, n = 0 | r2.length; t2 < n; t2++) {
    e = (e << 5) + e + r2.charCodeAt(t2);
  }
  return e;
}
function hash(e) {
  return phash(5381, e) >>> 0;
}
var i = /* @__PURE__ */ new Set();
var s = /* @__PURE__ */ new WeakMap();
function stringify(e) {
  if (null === e || i.has(e)) {
    return "null";
  } else if ("object" != typeof e) {
    return JSON.stringify(e) || "";
  } else if (e.toJSON) {
    return stringify(e.toJSON());
  } else if (Array.isArray(e)) {
    var r2 = "[";
    for (var t2 = 0, n = e.length; t2 < n; t2++) {
      if (t2 > 0) {
        r2 += ",";
      }
      var a = stringify(e[t2]);
      r2 += a.length > 0 ? a : "null";
    }
    return r2 += "]";
  }
  var o2 = Object.keys(e).sort();
  if (!o2.length && e.constructor && e.constructor !== Object) {
    var u3 = s.get(e) || Math.random().toString(36).slice(2);
    s.set(e, u3);
    return '{"__key":"' + u3 + '"}';
  }
  i.add(e);
  var f2 = "{";
  for (var c2 = 0, l3 = o2.length; c2 < l3; c2++) {
    var h3 = o2[c2];
    var p3 = stringify(e[h3]);
    if (p3) {
      if (f2.length > 1) {
        f2 += ",";
      }
      f2 += stringify(h3) + ":" + p3;
    }
  }
  i.delete(e);
  return f2 += "}";
}
function stringifyVariables(e) {
  i.clear();
  return stringify(e);
}
var u2 = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var f = /([\s,]|#[^\n\r]+)+/g;
function replaceOutsideStrings(e, r2) {
  return r2 % 2 == 0 ? e.replace(f, " ").trim() : e;
}
function stringifyDocument(e) {
  var r2 = ("string" != typeof e ? e.loc && e.loc.source.body || print(e) : e).split(u2).map(replaceOutsideStrings).join("");
  if ("string" != typeof e) {
    var t2 = "definitions" in e && getOperationName(e);
    if (t2) {
      r2 = "# " + t2 + "\n" + r2;
    }
    if (!e.loc) {
      e.loc = {
        start: 0,
        end: r2.length,
        source: {
          body: r2,
          name: "gql",
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      };
    }
  }
  return r2;
}
var c = /* @__PURE__ */ new Map();
function keyDocument(e) {
  var r2;
  var n;
  if ("string" == typeof e) {
    r2 = hash(stringifyDocument(e));
    n = c.get(r2) || parse(e, {
      noLocation: true
    });
  } else {
    r2 = e.__key || hash(stringifyDocument(e));
    n = c.get(r2) || e;
  }
  if (!n.loc) {
    stringifyDocument(n);
  }
  n.__key = r2;
  c.set(r2, n);
  return n;
}
function createRequest(e, r2) {
  if (!r2) {
    r2 = {};
  }
  var t2 = keyDocument(e);
  return {
    key: phash(t2.__key, stringifyVariables(r2)) >>> 0,
    query: t2,
    variables: r2
  };
}
function getOperationName(e) {
  for (var t2 = 0, n = e.definitions.length; t2 < n; t2++) {
    var a = e.definitions[t2];
    if (a.kind === Kind.OPERATION_DEFINITION && a.name) {
      return a.name.value;
    }
  }
}
function getOperationType(e) {
  for (var t2 = 0, n = e.definitions.length; t2 < n; t2++) {
    var a = e.definitions[t2];
    if (a.kind === Kind.OPERATION_DEFINITION) {
      return a.operation;
    }
  }
}
function _extends() {
  return (_extends = Object.assign || function(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = arguments[r2];
      for (var n in t2) {
        if (Object.prototype.hasOwnProperty.call(t2, n)) {
          e[n] = t2[n];
        }
      }
    }
    return e;
  }).apply(this, arguments);
}
function makeResult(e, r2, t2) {
  if (!("data" in r2) && !("errors" in r2) || "path" in r2) {
    throw new Error("No Content");
  }
  return {
    operation: e,
    data: r2.data,
    error: Array.isArray(r2.errors) ? new o({
      graphQLErrors: r2.errors,
      response: t2
    }) : void 0,
    extensions: "object" == typeof r2.extensions && r2.extensions || void 0,
    hasNext: !!r2.hasNext
  };
}
function mergeResultPatch(e, r2, t2) {
  var n = _extends({}, e);
  n.hasNext = !!r2.hasNext;
  if (!("path" in r2)) {
    if ("data" in r2) {
      n.data = r2.data;
    }
    return n;
  }
  if (Array.isArray(r2.errors)) {
    n.error = new o({
      graphQLErrors: n.error ? n.error.graphQLErrors.concat(r2.errors) : r2.errors,
      response: t2
    });
  }
  var a = n.data = _extends({}, n.data);
  var i2 = 0;
  var s2;
  while (i2 < r2.path.length) {
    a = a[s2 = r2.path[i2++]] = Array.isArray(a[s2]) ? [].concat(a[s2]) : _extends({}, a[s2]);
  }
  _extends(a, r2.data);
  return n;
}
function makeErrorResult(e, r2, t2) {
  return {
    operation: e,
    data: void 0,
    error: new o({
      networkError: r2,
      response: t2
    }),
    extensions: void 0
  };
}
function shouldUseGet(e) {
  return "query" === e.kind && !!e.context.preferGetMethod;
}
function makeFetchBody(e) {
  return {
    query: print(e.query),
    operationName: getOperationName(e.query),
    variables: e.variables || void 0,
    extensions: void 0
  };
}
function makeFetchURL(e, r2) {
  var t2 = shouldUseGet(e);
  var n = e.context.url;
  if (!t2 || !r2) {
    return n;
  }
  var a = [];
  if (r2.operationName) {
    a.push("operationName=" + encodeURIComponent(r2.operationName));
  }
  if (r2.query) {
    a.push("query=" + encodeURIComponent(r2.query.replace(/#[^\n\r]+/g, " ").trim()));
  }
  if (r2.variables) {
    a.push("variables=" + encodeURIComponent(stringifyVariables(r2.variables)));
  }
  if (r2.extensions) {
    a.push("extensions=" + encodeURIComponent(stringifyVariables(r2.extensions)));
  }
  return n + "?" + a.join("&");
}
function makeFetchOptions(e, r2) {
  var t2 = shouldUseGet(e);
  var n = "function" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions || {};
  return _extends({}, n, {
    body: !t2 && r2 ? JSON.stringify(r2) : void 0,
    method: t2 ? "GET" : "POST",
    headers: t2 ? n.headers : _extends({}, {
      "content-type": "application/json"
    }, n.headers)
  });
}
var l2 = "undefined" != typeof Symbol ? Symbol.asyncIterator : null;
var h = "undefined" != typeof TextDecoder ? new TextDecoder() : null;
var p2 = /content-type:[^\r\n]*application\/json/i;
var d = /boundary="?([^=";]+)"?/i;
function makeFetchSource(e, r2, t2) {
  var n = "manual" === t2.redirect ? 400 : 300;
  var o2 = e.context.fetch;
  return make$1(function(a) {
    var i2 = a.next;
    var s2 = a.complete;
    var u3 = "undefined" != typeof AbortController ? new AbortController() : null;
    if (u3) {
      t2.signal = u3.signal;
    }
    var f2 = false;
    function executeIncrementalFetch(e2, r3, t3) {
      var n2 = t3.headers && t3.headers.get("Content-Type") || "";
      if (!/multipart\/mixed/i.test(n2)) {
        return t3.json().then(function(n3) {
          var a3 = makeResult(r3, n3, t3);
          f2 = true;
          e2(a3);
        });
      }
      var a2 = "---";
      var o3 = n2.match(d);
      if (o3) {
        a2 = "--" + o3[1];
      }
      var i3;
      var cancel = function() {
      };
      if (l2 && t3[l2]) {
        var s3 = t3[l2]();
        i3 = s3.next.bind(s3);
      } else if ("body" in t3 && t3.body) {
        var u4 = t3.body.getReader();
        cancel = u4.cancel.bind(u4);
        i3 = u4.read.bind(u4);
      } else {
        throw new TypeError("Streaming requests unsupported");
      }
      var c3 = "";
      var v2 = true;
      var m3 = null;
      var g = null;
      return i3().then(function next(n3) {
        if (!n3.done) {
          var o4 = function toString(e3) {
            return "Buffer" === e3.constructor.name ? e3.toString() : h.decode(e3);
          }(n3.value);
          var s4 = o4.indexOf(a2);
          if (s4 > -1) {
            s4 += c3.length;
          } else {
            s4 = c3.indexOf(a2);
          }
          c3 += o4;
          while (s4 > -1) {
            var u5 = c3.slice(0, s4);
            var l3 = c3.slice(s4 + a2.length);
            if (v2) {
              v2 = false;
            } else {
              var d2 = u5.indexOf("\r\n\r\n") + 4;
              var y = u5.slice(0, d2);
              var x2 = u5.slice(d2, u5.lastIndexOf("\r\n"));
              var b = void 0;
              if (p2.test(y)) {
                try {
                  b = JSON.parse(x2);
                  m3 = g = g ? mergeResultPatch(g, b, t3) : makeResult(r3, b, t3);
                } catch (e3) {
                }
              }
              if ("--" === l3.slice(0, 2) || b && !b.hasNext) {
                if (!g) {
                  return e2(makeResult(r3, {}, t3));
                }
                break;
              }
            }
            s4 = (c3 = l3).indexOf(a2);
          }
        } else {
          f2 = true;
        }
        if (m3) {
          e2(m3);
          m3 = null;
        }
        if (!n3.done && (!g || g.hasNext)) {
          return i3().then(next);
        }
      }).finally(cancel);
    }
    var c2 = false;
    var v = false;
    var m2;
    Promise.resolve().then(function() {
      if (c2) {
        return;
      }
      return (o2 || fetch)(r2, t2);
    }).then(function(r3) {
      if (!r3) {
        return;
      }
      v = (m2 = r3).status < 200 || m2.status >= n;
      return executeIncrementalFetch(i2, e, m2);
    }).then(s2).catch(function(r3) {
      if (f2) {
        throw r3;
      }
      if ("AbortError" !== r3.name) {
        var t3 = makeErrorResult(e, v ? new Error(m2.statusText) : r3, m2);
        i2(t3);
        s2();
      }
    });
    return function() {
      c2 = true;
      if (u3) {
        u3.abort();
      }
    };
  });
}

// node_modules/@urql/core/dist/urql-core.mjs
function collectTypes(e, r2) {
  if (Array.isArray(e)) {
    for (var n = 0; n < e.length; n++) {
      collectTypes(e[n], r2);
    }
  } else if ("object" == typeof e && null !== e) {
    for (var t2 in e) {
      if ("__typename" === t2 && "string" == typeof e[t2]) {
        r2[e[t2]] = 0;
      } else {
        collectTypes(e[t2], r2);
      }
    }
  }
  return r2;
}
function collectTypesFromResponse(e) {
  return Object.keys(collectTypes(e, {}));
}
var formatNode = function(e) {
  if (e.selectionSet && !e.selectionSet.selections.some(function(e2) {
    return e2.kind === Kind.FIELD && "__typename" === e2.name.value && !e2.alias;
  })) {
    return _extends({}, e, {
      selectionSet: _extends({}, e.selectionSet, {
        selections: e.selectionSet.selections.concat([{
          kind: Kind.FIELD,
          name: {
            kind: Kind.NAME,
            value: "__typename"
          }
        }])
      })
    });
  }
};
var Q = /* @__PURE__ */ new Map();
function formatDocument(r2) {
  var n = keyDocument(r2);
  var a = Q.get(n.__key);
  if (!a) {
    a = visit(n, {
      Field: formatNode,
      InlineFragment: formatNode
    });
    Object.defineProperty(a, "__key", {
      value: n.__key,
      enumerable: false
    });
    Q.set(n.__key, a);
  }
  return a;
}
function maskTypename(e) {
  if (!e || "object" != typeof e) {
    return e;
  }
  return Object.keys(e).reduce(function(r2, n) {
    var t2 = e[n];
    if ("__typename" === n) {
      Object.defineProperty(r2, "__typename", {
        enumerable: false,
        value: t2
      });
    } else if (Array.isArray(t2)) {
      r2[n] = t2.map(maskTypename);
    } else if (t2 && "object" == typeof t2 && "__typename" in t2) {
      r2[n] = maskTypename(t2);
    } else {
      r2[n] = t2;
    }
    return r2;
  }, Array.isArray(e) ? [] : {});
}
function withPromise(e) {
  e.toPromise = function() {
    return toPromise$1(take$1(1)(filter$1(function(e2) {
      return !e2.stale && !e2.hasNext;
    })(e)));
  };
  return e;
}
function makeOperation(e, r2, n) {
  if (!n) {
    n = r2.context;
  }
  return {
    key: r2.key,
    query: r2.query,
    variables: r2.variables,
    kind: e,
    context: n
  };
}
function addMetadata(e, r2) {
  return makeOperation(e.kind, e, _extends({}, e.context, {
    meta: _extends({}, e.context.meta, r2)
  }));
}
function noop() {
}
function applyDefinitions(e, n, t2) {
  for (var a = 0; a < t2.length; a++) {
    if (t2[a].kind === Kind.FRAGMENT_DEFINITION) {
      var o2 = t2[a].name.value;
      var i2 = stringifyDocument(t2[a]);
      if (!e.has(o2)) {
        e.set(o2, i2);
        n.push(t2[a]);
      } else if (e.get(o2) !== i2) {
        console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + o2 + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
      }
    } else {
      n.push(t2[a]);
    }
  }
}
function gql() {
  var e = arguments;
  var n = /* @__PURE__ */ new Map();
  var a = [];
  var o2 = [];
  var i2 = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (var u3 = 1; u3 < arguments.length; u3++) {
    var c2 = e[u3];
    if (c2 && c2.definitions) {
      o2.push.apply(o2, c2.definitions);
    } else {
      i2 += c2;
    }
    i2 += e[0][u3];
  }
  applyDefinitions(n, a, keyDocument(i2).definitions);
  applyDefinitions(n, a, o2);
  return keyDocument({
    kind: Kind.DOCUMENT,
    definitions: a
  });
}
function shouldSkip(e) {
  var r2 = e.kind;
  return "mutation" !== r2 && "query" !== r2;
}
function cacheExchange(e) {
  var r2 = e.forward;
  var n = e.client;
  var t2 = e.dispatchDebug;
  var a = /* @__PURE__ */ new Map();
  var i2 = /* @__PURE__ */ Object.create(null);
  function mapTypeNames(e2) {
    var r3 = makeOperation(e2.kind, e2);
    r3.query = formatDocument(e2.query);
    return r3;
  }
  function isOperationCached(e2) {
    var r3 = e2.context.requestPolicy;
    return "query" === e2.kind && "network-only" !== r3 && ("cache-only" === r3 || a.has(e2.key));
  }
  return function(e2) {
    var u3 = share$1(e2);
    var c2 = map$1(function(e3) {
      var r3 = a.get(e3.key);
      t2(_extends({}, {
        operation: e3
      }, r3 ? {
        type: "cacheHit",
        message: "The result was successfully retried from the cache"
      } : {
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache"
      }));
      var i3 = _extends({}, r3, {
        operation: addMetadata(e3, {
          cacheOutcome: r3 ? "hit" : "miss"
        })
      });
      if ("cache-and-network" === e3.context.requestPolicy) {
        i3.stale = true;
        reexecuteOperation(n, e3);
      }
      return i3;
    })(filter$1(function(e3) {
      return !shouldSkip(e3) && isOperationCached(e3);
    })(u3));
    var s2 = H(function(e3) {
      var r3 = e3.operation;
      if (!r3) {
        return;
      }
      var o2 = collectTypesFromResponse(e3.data).concat(r3.context.additionalTypenames || []);
      if ("mutation" === e3.operation.kind) {
        var u4 = /* @__PURE__ */ new Set();
        t2({
          type: "cacheInvalidation",
          message: "The following typenames have been invalidated: " + o2,
          operation: r3,
          data: {
            typenames: o2,
            response: e3
          },
          source: "cacheExchange"
        });
        for (var c3 = 0; c3 < o2.length; c3++) {
          var s3 = o2[c3];
          var f2 = i2[s3] || (i2[s3] = /* @__PURE__ */ new Set());
          f2.forEach(function(e4) {
            u4.add(e4);
          });
          f2.clear();
        }
        u4.forEach(function(e4) {
          if (a.has(e4)) {
            r3 = a.get(e4).operation;
            a.delete(e4);
            reexecuteOperation(n, r3);
          }
        });
      } else if ("query" === r3.kind && e3.data) {
        a.set(r3.key, e3);
        for (var p3 = 0; p3 < o2.length; p3++) {
          var l3 = o2[p3];
          (i2[l3] || (i2[l3] = /* @__PURE__ */ new Set())).add(r3.key);
        }
      }
    })(r2(filter$1(function(e3) {
      return "query" !== e3.kind || "cache-only" !== e3.context.requestPolicy;
    })(map$1(function(e3) {
      return addMetadata(e3, {
        cacheOutcome: "miss"
      });
    })(merge$1([map$1(mapTypeNames)(filter$1(function(e3) {
      return !shouldSkip(e3) && !isOperationCached(e3);
    })(u3)), filter$1(function(e3) {
      return shouldSkip(e3);
    })(u3)])))));
    return merge$1([c2, s2]);
  };
}
function reexecuteOperation(e, r2) {
  return e.reexecuteOperation(makeOperation(r2.kind, r2, _extends({}, r2.context, {
    requestPolicy: "network-only"
  })));
}
var G = /* @__PURE__ */ new Set();
function ssrExchange(e) {
  var r2 = !(!e || !e.staleWhileRevalidate);
  var n = !(!e || !e.includeExtensions);
  var t2 = {};
  var a = [];
  function invalidate(e2) {
    a.push(e2.operation.key);
    if (1 === a.length) {
      Promise.resolve().then(function() {
        var e3;
        while (e3 = a.shift()) {
          t2[e3] = null;
        }
      });
    }
  }
  var ssr = function(a2) {
    var o2 = a2.client;
    var i2 = a2.forward;
    return function(a3) {
      var u3 = e && "boolean" == typeof e.isClient ? !!e.isClient : !o2.suspense;
      var s2 = share$1(a3);
      var f2 = i2(filter$1(function(e2) {
        return !t2[e2.key] || !!t2[e2.key].hasNext;
      })(s2));
      var p3 = map$1(function(e2) {
        var a4 = function deserializeResult(e3, r3, n2) {
          return {
            operation: e3,
            data: r3.data ? JSON.parse(r3.data) : void 0,
            extensions: n2 && r3.extensions ? JSON.parse(r3.extensions) : void 0,
            error: r3.error ? new o({
              networkError: r3.error.networkError ? new Error(r3.error.networkError) : void 0,
              graphQLErrors: r3.error.graphQLErrors
            }) : void 0,
            hasNext: r3.hasNext
          };
        }(e2, t2[e2.key], n);
        if (r2 && !G.has(e2.key)) {
          a4.stale = true;
          G.add(e2.key);
          reexecuteOperation(o2, e2);
        }
        return a4;
      })(filter$1(function(e2) {
        return !!t2[e2.key] && "network-only" !== e2.context.requestPolicy;
      })(s2));
      if (!u3) {
        f2 = H(function(e2) {
          var r3 = e2.operation;
          if ("mutation" !== r3.kind) {
            var a4 = function serializeResult(e3, r4) {
              var n2 = e3.hasNext;
              var t3 = e3.data;
              var a5 = e3.extensions;
              var o3 = e3.error;
              var i3 = {};
              if (void 0 !== t3) {
                i3.data = JSON.stringify(t3);
              }
              if (r4 && void 0 !== a5) {
                i3.extensions = JSON.stringify(a5);
              }
              if (n2) {
                i3.hasNext = true;
              }
              if (o3) {
                i3.error = {
                  graphQLErrors: o3.graphQLErrors.map(function(e4) {
                    if (!e4.path && !e4.extensions) {
                      return e4.message;
                    }
                    return {
                      message: e4.message,
                      path: e4.path,
                      extensions: e4.extensions
                    };
                  })
                };
                if (o3.networkError) {
                  i3.error.networkError = "" + o3.networkError;
                }
              }
              return i3;
            }(e2, n);
            t2[r3.key] = a4;
          }
        })(f2);
      } else {
        p3 = H(invalidate)(p3);
      }
      return merge$1([f2, p3]);
    };
  };
  ssr.restoreData = function(e2) {
    for (var r3 in e2) {
      if (null !== t2[r3]) {
        t2[r3] = e2[r3];
      }
    }
  };
  ssr.extractData = function() {
    var e2 = {};
    for (var r3 in t2) {
      if (null != t2[r3]) {
        e2[r3] = t2[r3];
      }
    }
    return e2;
  };
  if (e && e.initialState) {
    ssr.restoreData(e.initialState);
  }
  return ssr;
}
function subscriptionExchange(e) {
  var r2 = e.forwardSubscription;
  var t2 = e.enableAllOperations;
  return function(e2) {
    var a = e2.client;
    var i2 = e2.forward;
    function isSubscriptionOperation(e3) {
      var r3 = e3.kind;
      return "subscription" === r3 || !!t2 && ("query" === r3 || "mutation" === r3);
    }
    return function(e3) {
      var t3 = share$1(e3);
      var u3 = D(function(e4) {
        var i3 = e4.key;
        var u4 = filter$1(function(e5) {
          return "teardown" === e5.kind && e5.key === i3;
        })(t3);
        return takeUntil$1(u4)(function createSubscriptionSource(e5) {
          var t4 = r2({
            key: e5.key.toString(36),
            query: print(e5.query),
            variables: e5.variables,
            context: _extends({}, e5.context)
          });
          return make$1(function(r3) {
            var n = r3.next;
            var o2 = r3.complete;
            var i4 = false;
            var u5;
            Promise.resolve().then(function() {
              if (i4) {
                return;
              }
              u5 = t4.subscribe({
                next: function(r4) {
                  return n(makeResult(e5, r4));
                },
                error: function(r4) {
                  return n(makeErrorResult(e5, r4));
                },
                complete: function() {
                  if (!i4) {
                    i4 = true;
                    if ("subscription" === e5.kind) {
                      a.reexecuteOperation(makeOperation("teardown", e5, e5.context));
                    }
                    o2();
                  }
                }
              });
            });
            return function() {
              i4 = true;
              if (u5) {
                u5.unsubscribe();
              }
            };
          });
        }(e4));
      })(filter$1(isSubscriptionOperation)(t3));
      var c2 = i2(filter$1(function(e4) {
        return !isSubscriptionOperation(e4);
      })(t3));
      return merge$1([u3, c2]);
    };
  };
}
function debugExchange(e) {
  var r2 = e.forward;
  if (false) {
    return function(e2) {
      return r2(e2);
    };
  } else {
    return function(e2) {
      return H(function(e3) {
        return console.log("[Exchange debug]: Completed operation: ", e3);
      })(r2(H(function(e3) {
        return console.log("[Exchange debug]: Incoming operation: ", e3);
      })(e2)));
    };
  }
}
function dedupExchange(e) {
  var r2 = e.forward;
  var n = e.dispatchDebug;
  var t2 = /* @__PURE__ */ new Set();
  function filterIncomingOperation(e2) {
    var r3 = e2.key;
    var a = e2.kind;
    if ("teardown" === a) {
      t2.delete(r3);
      return true;
    }
    if ("query" !== a && "subscription" !== a) {
      return true;
    }
    var o2 = t2.has(r3);
    t2.add(r3);
    if (o2) {
      n({
        type: "dedup",
        message: "An operation has been deduped.",
        operation: e2,
        source: "dedupExchange"
      });
    }
    return !o2;
  }
  function afterOperationResult(e2) {
    if (!e2.hasNext) {
      t2.delete(e2.operation.key);
    }
  }
  return function(e2) {
    var n2 = filter$1(filterIncomingOperation)(e2);
    return H(afterOperationResult)(r2(n2));
  };
}
function fetchExchange(e) {
  var r2 = e.forward;
  var n = e.dispatchDebug;
  return function(e2) {
    var t2 = share$1(e2);
    var a = D(function(e3) {
      var r3 = e3.key;
      var a2 = filter$1(function(e4) {
        return "teardown" === e4.kind && e4.key === r3;
      })(t2);
      var o3 = makeFetchBody(e3);
      var i2 = makeFetchURL(e3, o3);
      var u3 = makeFetchOptions(e3, o3);
      n({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: e3,
        data: {
          url: i2,
          fetchOptions: u3
        },
        source: "fetchExchange"
      });
      return H(function(r4) {
        var t3 = !r4.data ? r4.error : void 0;
        n({
          type: t3 ? "fetchError" : "fetchSuccess",
          message: "A " + (t3 ? "failed" : "successful") + " fetch response has been returned.",
          operation: e3,
          data: {
            url: i2,
            fetchOptions: u3,
            value: t3 || r4
          },
          source: "fetchExchange"
        });
      })(takeUntil$1(a2)(makeFetchSource(e3, i2, u3)));
    })(filter$1(function(e3) {
      return "query" === e3.kind || "mutation" === e3.kind;
    })(t2));
    var o2 = r2(filter$1(function(e3) {
      return "query" !== e3.kind && "mutation" !== e3.kind;
    })(t2));
    return merge$1([a, o2]);
  };
}
function fallbackExchange(e) {
  var r2 = e.dispatchDebug;
  return function(e2) {
    return filter$1(function() {
      return false;
    })(H(function(e3) {
      if ("teardown" !== e3.kind && true) {
        var n = 'No exchange has handled operations of kind "' + e3.kind + `". Check whether you've added an exchange responsible for these operations.`;
        r2({
          type: "fallbackCatch",
          message: n,
          operation: e3,
          source: "fallbackExchange"
        });
        console.warn(n);
      }
    })(e2));
  };
}
var L = fallbackExchange({
  dispatchDebug: noop
});
function composeExchanges(e) {
  return function(r2) {
    var n = r2.client;
    var t2 = r2.dispatchDebug;
    return e.reduceRight(function(e2, r3) {
      return r3({
        client: n,
        forward: e2,
        dispatchDebug: function dispatchDebug$1(e3) {
          t2(_extends({}, {
            timestamp: Date.now(),
            source: r3.name
          }, e3));
        }
      });
    }, r2.forward);
  };
}
function errorExchange(e) {
  var r2 = e.onError;
  return function(e2) {
    var n = e2.forward;
    return function(e3) {
      return H(function(e4) {
        var n2 = e4.error;
        if (n2) {
          r2(n2, e4.operation);
        }
      })(n(e3));
    };
  };
}
var J2 = [dedupExchange, cacheExchange, fetchExchange];
var W = function Client(e) {
  if (!e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r2 = /* @__PURE__ */ new Map();
  var n = /* @__PURE__ */ new Map();
  var t2 = [];
  var a = makeSubject$1();
  var i2 = a.source;
  var u3 = a.next;
  var c2 = false;
  function dispatchOperation(e2) {
    c2 = true;
    if (e2) {
      u3(e2);
    }
    while (e2 = t2.shift()) {
      u3(e2);
    }
    c2 = false;
  }
  function makeResultSource(e2) {
    var a2 = filter$1(function(r3) {
      return r3.operation.kind === e2.kind && r3.operation.key === e2.key && (!r3.operation.context._instance || r3.operation.context._instance === e2.context._instance);
    })(y);
    if (f2.maskTypename) {
      a2 = map$1(function(e3) {
        return _extends({}, e3, {
          data: maskTypename(e3.data)
        });
      })(a2);
    }
    if ("mutation" === e2.kind) {
      return take$1(1)(onStart$1(function() {
        return dispatchOperation(e2);
      })(a2));
    }
    return share$1(onEnd$1(function() {
      r2.delete(e2.key);
      n.delete(e2.key);
      for (var a3 = t2.length - 1; a3 >= 0; a3--) {
        if (t2[a3].key === e2.key) {
          t2.splice(a3, 1);
        }
      }
      dispatchOperation(makeOperation("teardown", e2, e2.context));
    })(H(function(n2) {
      r2.set(e2.key, n2);
    })(K(function(r3) {
      if ("query" !== e2.kind || r3.stale) {
        return fromValue$1(r3);
      }
      return merge$1([fromValue$1(r3), map$1(function() {
        return _extends({}, r3, {
          stale: true
        });
      })(take$1(1)(filter$1(function(r4) {
        return "query" === r4.kind && r4.key === e2.key && "cache-only" !== r4.context.requestPolicy;
      })(i2)))]);
    })(takeUntil$1(filter$1(function(r3) {
      return "teardown" === r3.kind && r3.key === e2.key;
    })(i2))(a2)))));
  }
  var s2 = this instanceof Client ? this : Object.create(Client.prototype);
  var f2 = _extends(s2, {
    url: e.url,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    suspense: !!e.suspense,
    requestPolicy: e.requestPolicy || "cache-first",
    preferGetMethod: !!e.preferGetMethod,
    maskTypename: !!e.maskTypename,
    operations$: i2,
    reexecuteOperation: function reexecuteOperation2(e2) {
      if ("mutation" === e2.kind || n.has(e2.key)) {
        t2.push(e2);
        if (!c2) {
          Promise.resolve().then(dispatchOperation);
        }
      }
    },
    createOperationContext: function createOperationContext(e2) {
      if (!e2) {
        e2 = {};
      }
      return _extends({}, {
        _instance: void 0,
        url: f2.url,
        fetchOptions: f2.fetchOptions,
        fetch: f2.fetch,
        preferGetMethod: f2.preferGetMethod
      }, e2, {
        suspense: e2.suspense || false !== e2.suspense && f2.suspense,
        requestPolicy: e2.requestPolicy || f2.requestPolicy
      });
    },
    createRequestOperation: function createRequestOperation(e2, r3, n2) {
      var t3 = getOperationType(r3.query);
      if ("teardown" !== e2 && t3 !== e2) {
        throw new Error('Expected operation of type "' + e2 + '" but found "' + t3 + '"');
      }
      var a2 = f2.createOperationContext(n2);
      if ("mutation" === e2) {
        a2._instance = [];
      }
      return makeOperation(e2, r3, a2);
    },
    executeRequestOperation: function executeRequestOperation(e2) {
      if ("mutation" === e2.kind) {
        return makeResultSource(e2);
      }
      return make$1(function(t3) {
        var a2 = n.get(e2.key);
        if (!a2) {
          n.set(e2.key, a2 = makeResultSource(e2));
        }
        var i3 = "cache-and-network" === e2.context.requestPolicy || "network-only" === e2.context.requestPolicy;
        return N(t3.next)(onEnd$1(t3.complete)(onStart$1(function() {
          var n2 = r2.get(e2.key);
          if ("subscription" === e2.kind) {
            return dispatchOperation(e2);
          } else if (i3) {
            dispatchOperation(e2);
          }
          if (null != n2 && n2 === r2.get(e2.key)) {
            t3.next(i3 ? _extends({}, n2, {
              stale: true
            }) : n2);
          } else if (!i3) {
            dispatchOperation(e2);
          }
        })(a2))).unsubscribe;
      });
    },
    executeQuery: function executeQuery(e2, r3) {
      var n2 = f2.createRequestOperation("query", e2, r3);
      return f2.executeRequestOperation(n2);
    },
    executeSubscription: function executeSubscription(e2, r3) {
      var n2 = f2.createRequestOperation("subscription", e2, r3);
      return f2.executeRequestOperation(n2);
    },
    executeMutation: function executeMutation(e2, r3) {
      var n2 = f2.createRequestOperation("mutation", e2, r3);
      return f2.executeRequestOperation(n2);
    },
    query: function query(e2, r3, n2) {
      if (!n2 || "boolean" != typeof n2.suspense) {
        n2 = _extends({}, n2, {
          suspense: false
        });
      }
      return withPromise(f2.executeQuery(createRequest(e2, r3), n2));
    },
    readQuery: function readQuery(e2, r3, n2) {
      var t3 = null;
      N(function(e3) {
        t3 = e3;
      })(f2.query(e2, r3, n2)).unsubscribe();
      return t3;
    },
    subscription: function subscription(e2, r3, n2) {
      return f2.executeSubscription(createRequest(e2, r3), n2);
    },
    mutation: function mutation(e2, r3, n2) {
      return withPromise(f2.executeMutation(createRequest(e2, r3), n2));
    }
  });
  var p3 = noop;
  if (true) {
    var l3 = makeSubject$1();
    var d2 = l3.next;
    var v = l3.source;
    f2.subscribeToDebugTarget = function(e2) {
      return N(e2)(v);
    };
    p3 = d2;
  }
  var h3 = composeExchanges(void 0 !== e.exchanges ? e.exchanges : J2);
  var y = share$1(h3({
    client: f2,
    dispatchDebug: p3,
    forward: fallbackExchange({
      dispatchDebug: p3
    })
  })(i2));
  publish$1(y);
  return f2;
};
var z = W;

// node_modules/@urql/vue/dist/urql-vue.mjs
function _extends2() {
  return (_extends2 = Object.assign || function(e) {
    for (var u3 = 1; u3 < arguments.length; u3++) {
      var r2 = arguments[u3];
      for (var n in r2) {
        if (Object.prototype.hasOwnProperty.call(r2, n)) {
          e[n] = r2[n];
        }
      }
    }
    return e;
  }).apply(this, arguments);
}
function provideClient(u3) {
  var a;
  if (!isRef(u3)) {
    a = ref(u3 instanceof W ? u3 : new W(u3));
  } else {
    a = u3;
  }
  provide("$urql", a);
  return a.value;
}
function install(u3, t2) {
  var a;
  if (!isRef(t2)) {
    a = ref(t2 instanceof W ? t2 : new W(t2));
  } else {
    a = t2;
  }
  u3.provide("$urql", a);
}
function useClient() {
  if (!getCurrentInstance()) {
    throw new Error("use* functions may only be called during the `setup()` or other lifecycle hooks.");
  }
  var e = inject("$urql");
  if (!e) {
    throw new Error("No urql Client was provided. Did you forget to install the plugin or call `provideClient` in a parent?");
  }
  return e;
}
function unwrapPossibleProxy(e) {
  return e && isRef(e) ? e.value : e;
}
var x = {
  flush: "pre"
};
function useQuery(e) {
  return callUseQuery(e);
}
function callUseQuery(e, t2, a) {
  if (void 0 === t2) {
    t2 = useClient();
  }
  if (void 0 === a) {
    a = [];
  }
  var o2 = reactive(e);
  var s2 = ref();
  var v = ref(false);
  var h3 = ref(false);
  var b = ref();
  var w = ref();
  var P2 = ref();
  var Q2 = isRef(e.pause) ? e.pause : ref(!!e.pause);
  var S = ref(createRequest(o2.query, unwrapPossibleProxy(o2.variables)));
  var q = ref();
  a.push(watchEffect(function() {
    var e2 = createRequest(o2.query, unwrapPossibleProxy(o2.variables));
    if (S.value.key !== e2.key) {
      S.value = e2;
    }
  }, x));
  a.push(watchEffect(function() {
    q.value = !Q2.value ? t2.value.executeQuery(S.value, _extends2({}, {
      requestPolicy: o2.requestPolicy
    }, o2.context)) : void 0;
  }, x));
  var E2 = {
    data: s2,
    stale: v,
    error: b,
    operation: w,
    extensions: P2,
    fetching: h3,
    isPaused: Q2,
    executeQuery: function executeQuery(e2) {
      q.value = t2.value.executeQuery(S.value, _extends2({}, {
        requestPolicy: o2.requestPolicy
      }, o2.context, e2));
      return m2;
    },
    pause: function pause() {
      Q2.value = true;
    },
    resume: function resume() {
      Q2.value = false;
    }
  };
  a.push(watchEffect(function(e2) {
    if (q.value) {
      h3.value = true;
      v.value = false;
      e2(N(function(e3) {
        s2.value = e3.data;
        v.value = !!e3.stale;
        h3.value = false;
        b.value = e3.error;
        w.value = e3.operation;
        P2.value = e3.extensions;
      })(onEnd$1(function() {
        h3.value = false;
        v.value = false;
      })(q.value)).unsubscribe);
    } else {
      h3.value = false;
      v.value = false;
    }
  }, {
    flush: "sync"
  }));
  var m2 = _extends2({}, E2, {
    then: function then(e2, u3) {
      return (q.value ? toPromise$1(map$1(function() {
        return E2;
      })(take$1(1)(q.value))) : Promise.resolve(E2)).then(e2, u3);
    }
  });
  return m2;
}
function useMutation(e) {
  return callUseMutation(e);
}
function callUseMutation(e, r2) {
  if (void 0 === r2) {
    r2 = useClient();
  }
  var t2 = ref();
  var a = ref(false);
  var o2 = ref(false);
  var i2 = ref();
  var l3 = ref();
  var s2 = ref();
  return {
    data: t2,
    stale: a,
    fetching: o2,
    error: i2,
    operation: l3,
    extensions: s2,
    executeMutation: function executeMutation(n, v) {
      o2.value = true;
      return toPromise$1(take$1(1)(r2.value.executeMutation(createRequest(e, unwrapPossibleProxy(n)), v || {}))).then(function(e2) {
        t2.value = e2.data;
        a.value = !!e2.stale;
        o2.value = false;
        i2.value = e2.error;
        l3.value = e2.operation;
        s2.value = e2.extensions;
        return e2;
      });
    }
  };
}
var h2 = {
  flush: "pre"
};
function useSubscription(e, u3) {
  return callUseSubscription(e, u3);
}
function callUseSubscription(e, t2, a, o2) {
  if (void 0 === a) {
    a = useClient();
  }
  if (void 0 === o2) {
    o2 = [];
  }
  var s2 = reactive(e);
  var v = ref();
  var p3 = ref(false);
  var d2 = ref(false);
  var y = ref();
  var x2 = ref();
  var b = ref();
  var w = ref(t2);
  var P2 = isRef(e.pause) ? e.pause : ref(!!e.pause);
  var Q2 = ref(createRequest(s2.query, unwrapPossibleProxy(s2.variables)));
  var S = ref();
  o2.push(watchEffect(function() {
    var e2 = createRequest(s2.query, unwrapPossibleProxy(s2.variables));
    if (Q2.value.key !== e2.key) {
      Q2.value = e2;
    }
  }, h2));
  o2.push(watchEffect(function() {
    S.value = !P2.value ? a.value.executeSubscription(Q2.value, _extends2({}, s2.context)) : void 0;
  }, h2));
  o2.push(watchEffect(function(e2) {
    if (S.value) {
      d2.value = true;
      e2(N(function(e3) {
        d2.value = true;
        v.value = void 0 !== e3.data ? "function" == typeof w.value ? w.value(v.value, e3.data) : e3.data : e3.data, y.value = e3.error;
        b.value = e3.extensions;
        p3.value = !!e3.stale;
        x2.value = e3.operation;
      })(onEnd$1(function() {
        d2.value = false;
      })(S.value)).unsubscribe);
    } else {
      d2.value = false;
    }
  }, h2));
  var q = {
    data: v,
    stale: p3,
    error: y,
    operation: x2,
    extensions: b,
    fetching: d2,
    isPaused: P2,
    executeSubscription: function executeSubscription(e2) {
      S.value = a.value.executeSubscription(Q2.value, _extends2({}, s2.context, e2));
      return q;
    },
    pause: function pause() {
      P2.value = true;
    },
    resume: function resume() {
      P2.value = false;
    }
  };
  return q;
}
function useClientHandle() {
  var e = useClient();
  var u3 = [];
  onBeforeUnmount(function() {
    var e2;
    while (e2 = u3.shift()) {
      e2();
    }
  });
  var r2 = {
    client: e.value,
    useQuery: function useQuery2(r3) {
      return callUseQuery(r3, e, u3);
    },
    useSubscription: function useSubscription2(r3, n) {
      return callUseSubscription(r3, n, e, u3);
    },
    useMutation: function useMutation2(u4) {
      return callUseMutation(u4, e);
    }
  };
  if (true) {
    onMounted(function() {
      _extends2(r2, {
        useQuery: function useQuery2(r3) {
          if (!getCurrentInstance()) {
            throw new Error("`handle.useQuery()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseQuery(r3, e, u3);
        },
        useSubscription: function useSubscription2(r3, n) {
          if (!getCurrentInstance()) {
            throw new Error("`handle.useSubscription()` should only be called in the `setup()` or a lifecycle hook.");
          }
          return callUseSubscription(r3, n, e, u3);
        }
      });
    });
  }
  return r2;
}
var urql_vue_default = install;

// dep:@urql_vue
var urql_vue_default2 = urql_vue_default;
export {
  W as Client,
  o as CombinedError,
  cacheExchange,
  composeExchanges,
  z as createClient,
  createRequest,
  debugExchange,
  dedupExchange,
  urql_vue_default2 as default,
  J2 as defaultExchanges,
  errorExchange,
  L as fallbackExchangeIO,
  fetchExchange,
  formatDocument,
  getOperationName,
  gql,
  install,
  makeErrorResult,
  makeOperation,
  makeResult,
  maskTypename,
  mergeResultPatch,
  provideClient,
  ssrExchange,
  stringifyVariables,
  subscriptionExchange,
  useClientHandle,
  useMutation,
  useQuery,
  useSubscription
};
//# sourceMappingURL=@urql_vue.js.map
